using LLama.Abstractions;
using LLama.Common;
using LLama.Exceptions;
using LLama.Native;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;

namespace LLama
{
    /// <summary>
    /// The base class for stateful LLama executors.
    /// </summary>
    public abstract class StatefulExecutorBase : ILLamaExecutor
    {
        /// <summary>
        /// The logger used by this executor.
        /// </summary>
        protected ILogger? _logger;
        /// <summary>
        /// The tokens that were already processed by the model.
        /// </summary>
        protected int _pastTokensCount; // n_past
        /// <summary>
        /// The tokens that were consumed by the model during the current inference.
        /// </summary>
        protected int _consumedTokensCount; // n_consume
        /// <summary>
        /// Number of tokens consumed from the session cache during the current run.
        /// </summary>
        protected int _n_session_consumed;
        /// <summary>
        /// Number of prompt tokens that match the loaded session cache prefix.
        /// </summary>
        protected int _n_matching_session_tokens;
        /// <summary>
        /// The path of the session file.
        /// </summary>
        protected string? _pathSession;
        /// <summary>
        /// A container of the tokens to be processed and after processed.
        /// </summary>
        protected List<LLamaToken> _embeds = new(); // embd
        /// <summary>
        /// A container for the tokens of input.
        /// </summary>
        protected List<LLamaToken> _embed_inps = new();
        /// <summary>
        /// Tokens recovered from the session file and reused to warm up the KV cache.
        /// </summary>
        protected List<LLamaToken> _session_tokens = new();
        /// <summary>
        /// The last tokens generated by the model.
        /// </summary>
        protected FixedSizeQueue<LLamaToken> _last_n_tokens;
        /// <summary>
        /// The context used by the executor.
        /// </summary>
        public LLamaContext Context { get; }

        /// <summary>
        /// Tracks anti-prompts across streamed output.
        /// </summary>
        protected AntipromptProcessor AntipromptProcessor { get; }

        // Multimodal Section

        /// <inheritdoc />
        public bool IsMultiModal
        {
            get
            {
                return ClipModel != null;
            }
        }
        
        /// <inheritdoc />
        public MtmdWeights? ClipModel { get;  }

        /// <inheritdoc />
        public List<SafeMtmdEmbed> Embeds { get; }

        /// <summary>
        /// Pending multimodal chunks produced by the MTMD tokenizer.
        /// </summary>
        protected SafeMtmdInputChunks? MtmdChunks { get; set; }

        private string? _mtmdMarker;

        private readonly StreamingTokenDecoder _decoder;

        /// <summary>
        /// Initialize a stateful executor bound to a specific context.
        /// </summary>
        /// <param name="context">LLama context used for all native interactions.</param>
        /// <param name="logger">Optional logger for diagnostic output.</param>
        protected StatefulExecutorBase(LLamaContext context, ILogger? logger = null)
        {
            Embeds = new List<SafeMtmdEmbed>();
            _logger = logger;
            Context = context;
            _pastTokensCount = 0;
            _consumedTokensCount = 0;
            _n_session_consumed = 0;
            _last_n_tokens = new FixedSizeQueue<LLamaToken>((int)Context.ContextSize);
            _decoder = new StreamingTokenDecoder(context);
            AntipromptProcessor = new AntipromptProcessor();
        }
        
        /// <summary>
        /// Initialize a multimodal executor with the supplied MTMD weights.
        /// </summary>
        /// <param name="context">LLama context used for all native interactions.</param>
        /// <param name="mtmdWeights">Multimodal weights to associate with this executor.</param>
        /// <param name="logger">Optional logger for diagnostic output.</param>
        public StatefulExecutorBase(LLamaContext context, MtmdWeights mtmdWeights, ILogger? logger = null) : 
                        this( context, logger )
        {
            ClipModel = mtmdWeights;
        }

        /// <summary>
        /// Attach a session cache file so the executor can reuse previous KV state if compatible.
        /// </summary>
        /// <param name="filename">Path to the llama.cpp session file.</param>
        /// <returns>The current executor instance for fluent configuration.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="RuntimeError"></exception>
        public StatefulExecutorBase WithSessionFile(string filename)
        {
            _pathSession = filename;
            if (string.IsNullOrEmpty(filename))
            {
                throw new ArgumentNullException(nameof(filename), "File name cannot be empty.");
            }
            if (File.Exists(filename))
            {
                _logger?.LogInformation("[LLamaExecutor] Attempting to load saved session from {0}", filename);

                var session_tokens = new LLamaToken[Context.ContextSize];
                if (!NativeApi.llama_state_load_file(Context.NativeHandle, _pathSession, session_tokens, (ulong)Context.ContextSize, out var n_token_count_out))
                {
                    _logger?.LogError($"[LLamaExecutor] Failed to load session file {filename}");
                    throw new RuntimeError($"Failed to load session file {_pathSession}");
                }
                _session_tokens = session_tokens.Take((int)n_token_count_out).ToList();
                _logger?.LogInformation("[LLamaExecutor] Loaded a session with prompt size of {0} tokens", session_tokens.Length);
            }
            else
            {
                _logger?.LogWarning("[LLamaExecutor] Session file does not exist, will create");
            }

            _n_matching_session_tokens = 0;
            if (_session_tokens.Count > 0)
            {
                foreach (var id in _session_tokens)
                {
                    if (_n_matching_session_tokens >= _embed_inps.Count || id != _embed_inps[_n_matching_session_tokens])
                    {
                        break;
                    }
                    _n_matching_session_tokens++;
                }
                if (_n_matching_session_tokens >= _embed_inps.Count)
                {
                    _logger?.LogInformation("[LLamaExecutor] Session file has exact match for prompt!");
                }
                else if (_n_matching_session_tokens < _embed_inps.Count / 2)
                {
                    _logger?.LogWarning($"[LLamaExecutor] Session file has low similarity to prompt ({_n_matching_session_tokens} / {_embed_inps.Count} tokens) will mostly be reevaluated");
                }
                else
                {
                    _logger?.LogInformation($"[LLamaExecutor] Session file matches {_n_matching_session_tokens} / {_embed_inps.Count} tokens of prompt");
                }
            }

            return this;
        }

        /// <summary>
        /// Persist the current session cache to disk.
        /// </summary>
        /// <param name="filename">Destination path for the llama.cpp session file.</param>
        public void SaveSessionFile(string filename)
        {
            var session_token_array = _session_tokens.ToArray();
            NativeApi.llama_state_save_file(Context.NativeHandle, filename, session_token_array, (ulong)session_token_array.Length);
        }

        /// <summary>
        /// After running out of the context, take some tokens from the original prompt and recompute the logits in batches.
        /// </summary>
        /// <param name="tokensToKeep"></param>
        protected virtual void HandleRunOutOfContext(int tokensToKeep)
        {
            // if we run out of context:
            // - take the tokensToKeep first tokens from the original prompt (via n_past)
            // - take half of the last (n_ctx - tokensToKeep) tokens and recompute the logits in batches
            var n_left = _pastTokensCount - tokensToKeep;
            var n_discard = n_left / 2;

            Context.NativeHandle.MemorySequenceRemove(LLamaSeqId.Zero, tokensToKeep, tokensToKeep + n_discard);
            Context.NativeHandle.MemorySequenceAdd(LLamaSeqId.Zero, tokensToKeep + n_discard, _pastTokensCount, -n_discard);

            _pastTokensCount -= n_discard;
            // stop saving session if we run out of context
            _pathSession = string.Empty;
        }

        /// <summary>
        /// Try to reuse the matching prompt prefix from the loaded session cache before evaluating new tokens.
        /// </summary>
        protected virtual void TryReuseMatchingPrefix()
        {
            if (_n_session_consumed < _session_tokens.Count)
            {
                int i = 0;
                for (; i < _embeds.Count; i++)
                {
                    if (_embeds[i] != _session_tokens[_n_session_consumed])
                    {
                        if (_session_tokens.Count > _n_session_consumed)
                            _session_tokens.RemoveRange(_n_session_consumed, _session_tokens.Count - _n_session_consumed);
                        break;
                    }

                    _pastTokensCount++;
                    _n_session_consumed++;

                    if (_n_session_consumed >= _session_tokens.Count)
                    {
                        i++;
                        break;
                    }
                }

                if (i > 0)
                {
                    _embeds.RemoveRange(0, i);
                }
            }
        }

        /// <summary>
        /// Dispose and clear any queued multimodal chunk collection.
        /// </summary>
        protected void DisposeMtmdChunks()
        {
            MtmdChunks?.Dispose();
            MtmdChunks = null;
        }

        /// <summary>
        /// Dispose and clear any pending multimodal embeddings.
        /// </summary>
        protected void DisposeEmbeds()
        {
            if (Embeds.Count == 0)
                return;

            foreach (var embed in Embeds)
                embed.Dispose();

            Embeds.Clear();
        }

        /// <summary>
        /// Retrieve the marker token used to signal media segments to the tokenizer.
        /// </summary>
        protected string GetMtmdMarker()
        {
            if (_mtmdMarker is not null)
                return _mtmdMarker;

            _mtmdMarker = NativeApi.MtmdDefaultMarker() ?? "<media>";
            return _mtmdMarker;
        }

        /// <summary>
        /// Ensure the token list fills all positional slots reported by the MTMD helper.
        /// </summary>
        protected static List<LLamaToken> BuildTokensWithFiller(List<LLamaToken> tokens, int totalPositions, LLamaToken fillerToken)
        {
            if (totalPositions <= tokens.Count)
                return new List<LLamaToken>(tokens);

            var result = new List<LLamaToken>(totalPositions);
            result.AddRange(tokens);
            result.AddRange(Enumerable.Repeat(fillerToken, totalPositions - tokens.Count));
            return result;
        }

        /// <summary>
        /// Resolve the fallback token inserted when the tokenizer emits fewer tokens than positions.
        /// </summary>
        protected LLamaToken GetFillerToken(string marker)
        {
            var markerTokens = Context.Tokenize(marker, false, true);
            if (markerTokens.Length > 0)
                return markerTokens[markerTokens.Length - 1];

            var eos = Context.Vocab.EOS;
            if (eos.HasValue)
                return eos.Value;

            return default;
        }

        /// <summary>
        /// Prepare multimodal inputs by invoking the MTMD tokenizer and aligning filler tokens.
        /// </summary>
        protected Task PreprocessMtmd(string text, InferStateArgs args, bool addBos, bool replaceExisting)
        {
            if (ClipModel is null)
                throw new InvalidOperationException("Multimodal execution requires a loaded mtmd clip model.");

            DisposeMtmdChunks();

            var marker = GetMtmdMarker();
            var prompt = text;

            if (Embeds.Count > 0)
            {
                if (prompt.Contains("<image>"))
                    prompt = prompt.Replace("<image>", marker);

                if (!prompt.Contains(marker))
                {
                    var suffix = string.Concat(Enumerable.Repeat(marker, Embeds.Count));
                    prompt = string.Concat(prompt, suffix);
                }
            }

            SafeMtmdInputChunks? chunks = null;
            try
            {
                var status = ClipModel.Tokenize(prompt, addBos, parseSpecial: true, out chunks);
                if (status != 0 || chunks is null)
                {
                    ClipModel.ClearMedia();
                    throw new RuntimeError($"Failed to tokenize multimodal prompt. Status: {status}.");
                }

                MtmdChunks = chunks;

                var tokens = new List<LLamaToken>();
                foreach (var chunk in chunks.Enumerate())
                {
                    using var scopedChunk = chunk;
                    if (scopedChunk.Type != SafeMtmdInputChunk.SafeMtmdInputChunkType.Text)
                        continue;

                    foreach (var token in scopedChunk.GetTextTokensSpan())
                        tokens.Add(token);
                }

                var totalPositions = (int)ClipModel.CountPositions(chunks);
                var fillerToken = GetFillerToken(marker);

                if (replaceExisting)
                {
                    _embed_inps = BuildTokensWithFiller(tokens, totalPositions, fillerToken);
                    _consumedTokensCount = 0;
                }
                else
                {
                    if (_embed_inps.Count == 0)
                        _embed_inps = new List<LLamaToken>();

                    _embed_inps.AddRange(tokens);
                    var fillerCount = totalPositions - tokens.Count;
                    if (fillerCount > 0)
                        _embed_inps.AddRange(Enumerable.Repeat(fillerToken, fillerCount));

                    args.RemainedTokens -= tokens.Count;
                }
            }
            catch
            {
                chunks?.Dispose();
                MtmdChunks = null;
                throw;
            }
            finally
            {
                DisposeEmbeds();
            }

            return Task.CompletedTask;
        }

        /// <summary>
        /// Apply bookkeeping after successfully evaluating multimodal chunks.
        /// </summary>
        protected void FinalizeMtmdEvaluation(int newNPast, int previousConsumed)
        {
            _pastTokensCount = newNPast;
            DisposeMtmdChunks();

            if (!string.IsNullOrEmpty(_pathSession) && _embed_inps.Count > previousConsumed)
            {
                _session_tokens.AddRange(_embed_inps.Skip(previousConsumed));
                _n_session_consumed = _session_tokens.Count;
            }

            _consumedTokensCount = _embed_inps.Count;
            _embeds.Clear();
        }

        /// <summary>
        /// Evaluate the queued MTMD chunks and update executor state.
        /// </summary>
        protected void EvaluateMtmdChunks(ref int nPast, int previousConsumed, string executorName)
        {
            if (ClipModel is null)
                throw new InvalidOperationException("Multimodal execution requires a loaded mtmd clip model.");
            if (MtmdChunks is null)
                throw new InvalidOperationException("No MTMD chunks are queued for evaluation.");

            var evalStatus = ClipModel.EvaluateChunks(MtmdChunks, Context.NativeHandle, ref nPast, seqId: 0,
                nBatch: checked((int)Context.BatchSize), logitsLast: true);
            if (evalStatus != 0)
            {
                _logger?.LogError("[{Executor}] Failed to evaluate multimodal chunks. Status: {Status}", executorName, evalStatus);
                DisposeMtmdChunks();
                throw new RuntimeError($"Failed to evaluate multimodal chunks. Status: {evalStatus}.");
            }

            FinalizeMtmdEvaluation(nPast, previousConsumed);
        }

        /// <summary>
        /// Determine whether the inference loop should continue processing tokens.
        /// </summary>
        /// <param name="args">Mutable state associated with the current inference.</param>
        /// <param name="cancellationToken"></param>
        /// <returns><c>true</c> to continue generating; otherwise <c>false</c>.</returns>
        protected abstract Task<bool> GetLoopCondition(InferStateArgs args, CancellationToken cancellationToken = default);

        /// <summary>
        /// Prepare the executor for inference by tokenizing input and updating cached state.
        /// </summary>
        /// <param name="text">Prompt text to process.</param>
        /// <param name="args">Mutable state associated with the current inference.</param>
        /// <param name="cancellationToken"></param>
        protected abstract Task PreprocessInputs(string? text, InferStateArgs args, CancellationToken cancellationToken = default);

        /// <summary>
        /// Perform any post-processing on the generated tokens.
        /// </summary>
        /// <param name="inferenceParams">Parameters controlling sampling.</param>
        /// <param name="cancellationToken"></param>
        /// <param name="args">Mutable state associated with the current inference.</param>
        /// <returns>A tuple indicating whether generation should stop and any extra outputs to emit.</returns>
        protected abstract Task<(bool, IReadOnlyList<string>)> PostProcess(IInferenceParams inferenceParams, InferStateArgs args, CancellationToken cancellationToken = default);

        /// <summary>
        /// Core inference loop that advances the model by one step.
        /// </summary>
        /// <param name="inferenceParams">Parameters controlling sampling.</param>
        /// <param name="args">Mutable state associated with the current inference.</param>
        /// <param name="cancellationToken"></param>
        protected abstract Task InferInternal(IInferenceParams inferenceParams, InferStateArgs args, CancellationToken cancellationToken = default);

        /// <summary>
        /// Save the executor state to a serialized snapshot file.
        /// </summary>
        /// <param name="filename">Destination file for the serialized state.</param>
        /// <param name="cancellationToken"></param>
        public abstract Task SaveState(string filename, CancellationToken cancellationToken = default);

        /// <summary>
        /// Capture the executor state in a serializable object.
        /// </summary>
        /// <returns>State snapshot suitable for persistence.</returns>
        public abstract ExecutorBaseState GetStateData();

        /// <summary>
        /// Restore executor state from a previously captured snapshot.
        /// </summary>
        /// <param name="data">State snapshot created by <see cref="GetStateData"/>.</param>
        /// <param name="cancellationToken"></param>
        public abstract Task LoadState(ExecutorBaseState data, CancellationToken cancellationToken = default);

        /// <summary>
        /// Restore executor state from a serialized snapshot file.
        /// </summary>
        /// <param name="filename">Path to the snapshot produced by <see cref="SaveState"/>.</param>
        /// <param name="cancellationToken"></param>
        public abstract Task LoadState(string filename, CancellationToken cancellationToken = default);


        /// <summary>
        /// Execute an asynchronous inference session.
        /// </summary>
        /// <param name="text">Optional prompt; when null generation resumes from prior state.</param>
        /// <param name="inferenceParams">Sampling parameters to apply; defaults are used when null.</param>
        /// <param name="cancellationToken">Cancellation token for cooperative cancellation.</param>
        /// <returns>Stream of decoded text segments as they become available.</returns>
        public virtual async IAsyncEnumerable<string> InferAsync(string? text, IInferenceParams? inferenceParams = null, [EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            cancellationToken.ThrowIfCancellationRequested();
            inferenceParams ??= new InferenceParams();

            var args = new InferStateArgs
            {
                Antiprompts = [.. inferenceParams.AntiPrompts],
                RemainedTokens = inferenceParams.MaxTokens,
                ReturnValue = false,
                WaitForInput = false,
                NeedToSaveSession = !string.IsNullOrEmpty(_pathSession) && _n_matching_session_tokens < _embed_inps.Count
            };

            AntipromptProcessor.SetAntiprompts(inferenceParams.AntiPrompts ?? []);
            await PreprocessInputs(text, args, cancellationToken);

            while (await GetLoopCondition(args, cancellationToken))
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    break;
                }
                
                args.LastOutput = string.Empty;
                await InferInternal(inferenceParams, args, cancellationToken);

                if (args.ReturnValue)
                {
                    _decoder.AddRange(_embeds);
                    var decoded = _decoder.Read();
                    args.LastOutput = decoded;
                    yield return decoded;
                }

                var (breakGeneration, extraOutputs) = await PostProcess(inferenceParams, args, cancellationToken);
                if (extraOutputs is { Count: > 0 })
                {
                    foreach (var item in extraOutputs)
                    {
                        yield return item;
                    }
                }
                if (breakGeneration)
                {
                    break;
                }
            }
        }

        /// <summary>
        /// Asynchronously runs a prompt through the model to compute KV cache without generating any new tokens.
        /// It could reduce the latency of the first time response if the first input from the user is not immediate.
        /// </summary>
        /// <param name="prompt">Prompt to process</param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        public virtual async Task PrefillPromptAsync(string prompt, CancellationToken cancellationToken = default)
        {
            var inferenceParams = new InferenceParams
            {
                MaxTokens = 0
            };
            var args = new InferStateArgs
            {
                Antiprompts = [],
                RemainedTokens = 0,
                ReturnValue = false,
                WaitForInput = true,
                NeedToSaveSession = false
            };

            await PreprocessInputs(prompt, args, cancellationToken);
            // First run adds the prompt to the _embeds
            await InferInternal(inferenceParams, args, cancellationToken);
            // Second run puts it through decode
            await InferInternal(inferenceParams, args, cancellationToken);
        }   

        /// <summary>
        /// Mutable state passed between inference callbacks during a single generation pass.
        /// </summary>
        protected class InferStateArgs
        {
            /// <summary>
            /// Anti-prompts that terminate generation when encountered.
            /// </summary>
            public IList<string>? Antiprompts { get; set; }
            /// <summary>
            /// Tokens count remained to be used. (n_remain)
            /// </summary>
            public int RemainedTokens { get; set; }
            /// <summary>
            /// Indicates whether generated tokens should be returned to the caller.
            /// </summary>
            public bool ReturnValue { get; set; }
            /// <summary>
            /// Signals that the executor should pause and wait for additional user input.
            /// </summary>
            public bool WaitForInput { get; set; }
            /// <summary>
            /// Indicates whether the session cache should be persisted after inference completes.
            /// </summary>
            public bool NeedToSaveSession { get; set; }

            /// <summary>
            /// Most recent decoded output from the model.
            /// </summary>
            public string LastOutput { get; set; } = string.Empty;
        }

#pragma warning disable CS1591, CS8618 // Missing XML and irrelevant nullable warnings
        /// <summary>
        /// Serializable snapshot of executor state used for persistence and restart.
        /// </summary>
        [JsonConverter(typeof(PolymorphicJSONConverter<ExecutorBaseState>))]
        public class ExecutorBaseState
        {
            [JsonPropertyName("n_past")]
            public int PastTokensCount { get; set; }

            [JsonPropertyName("n_consumed")]
            public int ConsumedTokensCount { get; set; }

            [JsonPropertyName("n_session_consumed")]
            public int ConsumedSessionCount { get; set; }

            [JsonPropertyName("n_matching_session_tokens")]
            public int MatchingSessionTokensCount { get; set; }

            [JsonPropertyName("path_session")]
            public string? SessionFilePath { get; set; }

            [JsonPropertyName("embd")]
            public LLamaToken[] Embeds { get; set; }

            [JsonPropertyName("embd_inps")]
            public LLamaToken[] EmbedInps { get; set; }

            [JsonPropertyName("session_tokens")]
            public LLamaToken[] SessionTokens { get; set; }

            [JsonPropertyName("last_n_tokens")]
            public LLamaToken[] LastTokens { get; set; }

            [JsonPropertyName("last_tokens_maximum_count")]
            public int LastTokensCapacity { get; set; }

            [JsonPropertyName("mirostat_mu")]
            public float? MirostatMu { get; set; }
        }
#pragma warning restore

        internal ExecutorDiagnostics GetDiagnostics()
        {
            return new ExecutorDiagnostics(
                _embed_inps.Count,
                _consumedTokensCount,
                _pastTokensCount,
                _embeds.Count);
        }
    }
}

namespace LLama
{
    internal readonly struct ExecutorDiagnostics
    {
        public ExecutorDiagnostics(int embedCount, int consumedCount, int pastCount, int pendingEmbeds)
        {
            EmbedCount = embedCount;
            ConsumedCount = consumedCount;
            PastCount = pastCount;
            PendingEmbedCount = pendingEmbeds;
        }

        public int EmbedCount { get; }
        public int ConsumedCount { get; }
        public int PastCount { get; }
        public int PendingEmbedCount { get; }
    }
}
